#include "HiPassFilter.h"

/**
  * class HiPassFilter
  * Copyright 2014, Quakefinder
  * "$Id: HiPassFilter.cpp,v 5d4a5baeba5b 2015/04/03 17:25:17 jlemon $";
  *
  * Originally generated by Umbrello
 */


// Constructors/Destructors
//  

HiPassFilter::HiPassFilter ( ) {
  initAttributes();
}

HiPassFilter::HiPassFilter( const double &passF, const int &fLen ) {
  passFreq = passF;
  filtrLen = fLen;
}


HiPassFilter::~HiPassFilter() {}

//  
// Methods
//  


// Accessor methods
//  


// Other methods
//  

void HiPassFilter::initAttributes ( ) {
  passFreq = 0.0;
  filtrLen = 0;
  tossSecs = 0.0;
}


bool HiPassFilter::apply( const TimeData& src, TimeData& result ) const
{

 /*
  printf("Usage: %s n s f\n", argv[0]);
  printf("Butterworth Highpass filter.\n");
  printf("  n = filter order 2,4,6,...\n");
  printf("  s = sampling frequency\n");
  printf("  f = half power frequency\n");
 */

  int i, n = filtrLen;
  n = n/2;
  double s = src.getSampleRate();
  double f = passFreq;
  double a = tan(M_PI*f/s);
  double a2 = a*a;
  double r;
  double *A = (double *)malloc(n*sizeof(double));
  double *d1 = (double *)malloc(n*sizeof(double));
  double *d2 = (double *)malloc(n*sizeof(double));
  double *w0 = (double *)calloc(n, sizeof(double));
  double *w1 = (double *)calloc(n, sizeof(double));
  double *w2 = (double *)calloc(n, sizeof(double));
  double x;

//Dsp::Butterworth::Design::HighPass<50> arf;
//arf.setup(7,50,0.25);

#if 1

  /* Load filter taps */
  FILE* fid = fopen("/home/matlab/filter.txt","r");
  const int numTaps = 1373;
  double taps[numTaps];
  int nfread = fread( taps, sizeof(double), numTaps, fid );
  fclose(fid);
  std:cout << "numTaps = " << numTaps << " n = " << n << &endl;
  //for( int s = 0; s < numTaps; s++ ) printf( "%lf\n", taps[s] );

  int* samps = (int*)result.getData();
  size_t sampleCount = result.getSampleCount();
  std::cout << "Filtering " << sampleCount << " samples of data." << &endl;

  double *vv = NULL;
  if( !src.getVals( &vv ) ) {
    std::cerr << "src.getVals( &vv ) == false.  Conversion failed!!" << &endl;
    return false;
  }

  for(i=0; i<n; ++i){
    r = sin(M_PI*(2.0*i+1.0)/(4.0*n));
    s = a2 + 2.0*a*r + 1.0;
    A[i] = 1.0/s;
    d1[i] = 2.0*(1-a2)/s;
    d2[i] = -(a2 - 2.0*a*r + 1.0)/s;}


  for( size_t s = 0; s < sampleCount; s++ ) {
    for( i = 0; i < n; ++i ) {
      w0[i] = d1[i]*w1[i] + d2[i]*w2[i] + vv[s];
      vv[s] = A[i]*(w0[i] - 2.0*w1[i] + w2[i]);
      w2[i] = w1[i];
      w1[i] = w0[i];
    }
  }

  if( !result.setVals( vv, sampleCount ) ) {
    std::cerr << "result.setVals() == false.  Conversion failed!!" << &endl;
    return false;
  }


free(vv);

#else


  for(i=0; i<n; ++i){
    r = sin(M_PI*(2.0*i+1.0)/(4.0*n));
    s = a2 + 2.0*a*r + 1.0;
    A[i] = 1.0/s;
    d1[i] = 2.0*(1-a2)/s;
    d2[i] = -(a2 - 2.0*a*r + 1.0)/s;}

  while(scanf("%lf", &x)!=EOF){
    for(i=0; i<n; ++i){
      w0[i] = d1[i]*w1[i] + d2[i]*w2[i] + x;
      x = A[i]*(w0[i] - 2.0*w1[i] + w2[i]);
      w2[i] = w1[i];
      w1[i] = w0[i];}
    printf("%lf\n", x);}

#endif


  return true;


}
